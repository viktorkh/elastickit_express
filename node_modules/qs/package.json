{
  "_args": [
    [
      {
        "raw": "qs@github:ssetem/qs",
        "scope": null,
        "escapedName": "qs",
        "name": "qs",
        "rawSpec": "github:ssetem/qs",
        "spec": "github:ssetem/qs",
        "type": "hosted",
        "hosted": {
          "type": "github",
          "ssh": "git@github.com:ssetem/qs.git",
          "sshUrl": "git+ssh://git@github.com/ssetem/qs.git",
          "httpsUrl": "git+https://github.com/ssetem/qs.git",
          "gitUrl": "git://github.com/ssetem/qs.git",
          "shortcut": "github:ssetem/qs",
          "directUrl": "https://raw.githubusercontent.com/ssetem/qs/master/package.json"
        }
      },
      "C:\\react_projects\\searchkit_expressjs\\node_modules\\searchkit"
    ]
  ],
  "_from": "ssetem/qs",
  "_id": "qs@6.0.1",
  "_inCache": true,
  "_installable": true,
  "_location": "/qs",
  "_phantomChildren": {},
  "_requested": {
    "raw": "qs@github:ssetem/qs",
    "scope": null,
    "escapedName": "qs",
    "name": "qs",
    "rawSpec": "github:ssetem/qs",
    "spec": "github:ssetem/qs",
    "type": "hosted",
    "hosted": {
      "type": "github",
      "ssh": "git@github.com:ssetem/qs.git",
      "sshUrl": "git+ssh://git@github.com/ssetem/qs.git",
      "httpsUrl": "git+https://github.com/ssetem/qs.git",
      "gitUrl": "git://github.com/ssetem/qs.git",
      "shortcut": "github:ssetem/qs",
      "directUrl": "https://raw.githubusercontent.com/ssetem/qs/master/package.json"
    }
  },
  "_requiredBy": [
    "/searchkit"
  ],
  "_resolved": "git://github.com/ssetem/qs.git#fb2b80ac750fa375e0d69643adb0840e7e04d1d3",
  "_shasum": "6682661a8fcee8e38ac0eb4ff23a1c31abe329cd",
  "_shrinkwrap": null,
  "_spec": "qs@github:ssetem/qs",
  "_where": "C:\\react_projects\\searchkit_expressjs\\node_modules\\searchkit",
  "bugs": {
    "url": "https://github.com/hapijs/qs/issues"
  },
  "dependencies": {},
  "description": "A querystring parser that supports nesting and arrays, with a depth limit",
  "devDependencies": {
    "browserify": "^10.2.1",
    "code": "2.x.x",
    "lab": "7.x.x"
  },
  "engines": {
    "node": ">=4.0.0"
  },
  "gitHead": "fb2b80ac750fa375e0d69643adb0840e7e04d1d3",
  "homepage": "https://github.com/hapijs/qs",
  "keywords": [
    "querystring",
    "qs"
  ],
  "license": "BSD-3-Clause",
  "main": "lib/index.js",
  "name": "qs",
  "optionalDependencies": {},
  "readme": "# qs\r\n\r\nA querystring parsing and stringifying library with some added security.\r\n\r\n[![Build Status](https://secure.travis-ci.org/hapijs/qs.svg)](http://travis-ci.org/hapijs/qs)\r\n\r\nLead Maintainer: [Nathan LaFreniere](https://github.com/nlf)\r\n\r\nThe **qs** module was originally created and maintained by [TJ Holowaychuk](https://github.com/visionmedia/node-querystring).\r\n\r\n## Usage\r\n\r\n```javascript\r\nvar Qs = require('qs');\r\n\r\nvar obj = Qs.parse('a=c');    // { a: 'c' }\r\nvar str = Qs.stringify(obj);  // 'a=c'\r\n```\r\n\r\n### Parsing Objects\r\n\r\n```javascript\r\nQs.parse(string, [options]);\r\n```\r\n\r\n**qs** allows you to create nested objects within your query strings, by surrounding the name of sub-keys with square brackets `[]`.\r\nFor example, the string `'foo[bar]=baz'` converts to:\r\n\r\n```javascript\r\n{\r\n  foo: {\r\n    bar: 'baz'\r\n  }\r\n}\r\n```\r\n\r\nWhen using the `plainObjects` option the parsed value is returned as a plain object, created via `Object.create(null)` and as such you should be aware that prototype methods will not exist on it and a user may set those names to whatever value they like:\r\n\r\n```javascript\r\nQs.parse('a.hasOwnProperty=b', { plainObjects: true });\r\n// { a: { hasOwnProperty: 'b' } }\r\n```\r\n\r\nBy default parameters that would overwrite properties on the object prototype are ignored, if you wish to keep the data from those fields either use `plainObjects` as mentioned above, or set `allowPrototypes` to `true` which will allow user input to overwrite those properties. *WARNING* It is generally a bad idea to enable this option as it can cause problems when attempting to use the properties that have been overwritten. Always be careful with this option.\r\n\r\n```javascript\r\nQs.parse('a.hasOwnProperty=b', { allowPrototypes: true });\r\n// { a: { hasOwnProperty: 'b' } }\r\n```\r\n\r\nURI encoded strings work too:\r\n\r\n```javascript\r\nQs.parse('a%5Bb%5D=c');\r\n// { a: { b: 'c' } }\r\n```\r\n\r\nYou can also nest your objects, like `'foo[bar][baz]=foobarbaz'`:\r\n\r\n```javascript\r\n{\r\n  foo: {\r\n    bar: {\r\n      baz: 'foobarbaz'\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nBy default, when nesting objects **qs** will only parse up to 5 children deep. This means if you attempt to parse a string like\r\n`'a[b][c][d][e][f][g][h][i]=j'` your resulting object will be:\r\n\r\n```javascript\r\n{\r\n  a: {\r\n    b: {\r\n      c: {\r\n        d: {\r\n          e: {\r\n            f: {\r\n              '[g][h][i]': 'j'\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis depth can be overridden by passing a `depth` option to `Qs.parse(string, [options])`:\r\n\r\n```javascript\r\nQs.parse('a[b][c][d][e][f][g][h][i]=j', { depth: 1 });\r\n// { a: { b: { '[c][d][e][f][g][h][i]': 'j' } } }\r\n```\r\n\r\nThe depth limit helps mitigate abuse when **qs** is used to parse user input, and it is recommended to keep it a reasonably small number.\r\n\r\nFor similar reasons, by default **qs** will only parse up to 1000 parameters. This can be overridden by passing a `parameterLimit` option:\r\n\r\n```javascript\r\nQs.parse('a=b&c=d', { parameterLimit: 1 });\r\n// { a: 'b' }\r\n```\r\n\r\nAn optional delimiter can also be passed:\r\n\r\n```javascript\r\nQs.parse('a=b;c=d', { delimiter: ';' });\r\n// { a: 'b', c: 'd' }\r\n```\r\n\r\nDelimiters can be a regular expression too:\r\n\r\n```javascript\r\nQs.parse('a=b;c=d,e=f', { delimiter: /[;,]/ });\r\n// { a: 'b', c: 'd', e: 'f' }\r\n```\r\n\r\nOption `allowDots` can be used to enable dot notation:\r\n\r\n```javascript\r\nQs.parse('a.b=c', { allowDots: true });\r\n// { a: { b: 'c' } }\r\n```\r\n\r\n### Parsing Arrays\r\n\r\n**qs** can also parse arrays using a similar `[]` notation:\r\n\r\n```javascript\r\nQs.parse('a[]=b&a[]=c');\r\n// { a: ['b', 'c'] }\r\n```\r\n\r\nYou may specify an index as well:\r\n\r\n```javascript\r\nQs.parse('a[1]=c&a[0]=b');\r\n// { a: ['b', 'c'] }\r\n```\r\n\r\nNote that the only difference between an index in an array and a key in an object is that the value between the brackets must be a number\r\nto create an array. When creating arrays with specific indices, **qs** will compact a sparse array to only the existing values preserving\r\ntheir order:\r\n\r\n```javascript\r\nQs.parse('a[1]=b&a[15]=c');\r\n// { a: ['b', 'c'] }\r\n```\r\n\r\nNote that an empty string is also a value, and will be preserved:\r\n\r\n```javascript\r\nQs.parse('a[]=&a[]=b');\r\n// { a: ['', 'b'] }\r\nQs.parse('a[0]=b&a[1]=&a[2]=c');\r\n// { a: ['b', '', 'c'] }\r\n```\r\n\r\n**qs** will also limit specifying indices in an array to a maximum index of `20`. Any array members with an index of greater than `20` will\r\ninstead be converted to an object with the index as the key:\r\n\r\n```javascript\r\nQs.parse('a[100]=b');\r\n// { a: { '100': 'b' } }\r\n```\r\n\r\nThis limit can be overridden by passing an `arrayLimit` option:\r\n\r\n```javascript\r\nQs.parse('a[1]=b', { arrayLimit: 0 });\r\n// { a: { '1': 'b' } }\r\n```\r\n\r\nTo disable array parsing entirely, set `parseArrays` to `false`.\r\n\r\n```javascript\r\nQs.parse('a[]=b', { parseArrays: false });\r\n// { a: { '0': 'b' } }\r\n```\r\n\r\nIf you mix notations, **qs** will merge the two items into an object:\r\n\r\n```javascript\r\nQs.parse('a[0]=b&a[b]=c');\r\n// { a: { '0': 'b', b: 'c' } }\r\n```\r\n\r\nYou can also create arrays of objects:\r\n\r\n```javascript\r\nQs.parse('a[][b]=c');\r\n// { a: [{ b: 'c' }] }\r\n```\r\n\r\n### Stringifying\r\n\r\n```javascript\r\nQs.stringify(object, [options]);\r\n```\r\n\r\nWhen stringifying, **qs** by default URI encodes output. Objects are stringified as you would expect:\r\n\r\n```javascript\r\nQs.stringify({ a: 'b' });\r\n// 'a=b'\r\nQs.stringify({ a: { b: 'c' } });\r\n// 'a%5Bb%5D=c'\r\n```\r\n\r\nThis encoding can be disabled by setting the `encode` option to `false`:\r\n\r\n```javascript\r\nQs.stringify({ a: { b: 'c' } }, { encode: false });\r\n// 'a[b]=c'\r\n```\r\n\r\nExamples beyond this point will be shown as though the output is not URI encoded for clarity. Please note that the return values in these cases *will* be URI encoded during real usage.\r\n\r\nWhen arrays are stringified, by default they are given explicit indices:\r\n\r\n```javascript\r\nQs.stringify({ a: ['b', 'c', 'd'] });\r\n// 'a[0]=b&a[1]=c&a[2]=d'\r\n```\r\n\r\nYou may override this by setting the `indices` option to `false`:\r\n\r\n```javascript\r\nQs.stringify({ a: ['b', 'c', 'd'] }, { indices: false });\r\n// 'a=b&a=c&a=d'\r\n```\r\n\r\nYou may use the `arrayFormat` option to specify the format of the output array\r\n\r\n```javascript\r\nQs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'indices' })\r\n// 'a[0]=b&a[1]=c'\r\nQs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'brackets' })\r\n// 'a[]=b&a[]=c'\r\nQs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'repeat' })\r\n// 'a=b&a=c'\r\n```\r\n\r\nEmpty strings and null values will omit the value, but the equals sign (=) remains in place:\r\n\r\n```javascript\r\nQs.stringify({ a: '' });\r\n// 'a='\r\n```\r\n\r\nProperties that are set to `undefined` will be omitted entirely:\r\n\r\n```javascript\r\nQs.stringify({ a: null, b: undefined });\r\n// 'a='\r\n```\r\n\r\nThe delimiter may be overridden with stringify as well:\r\n\r\n```javascript\r\nQs.stringify({ a: 'b', c: 'd' }, { delimiter: ';' });\r\n// 'a=b;c=d'\r\n```\r\n\r\nFinally, you can use the `filter` option to restrict which keys will be included in the stringified output.\r\nIf you pass a function, it will be called for each key to obtain the replacement value. Otherwise, if you\r\npass an array, it will be used to select properties and array indices for stringification:\r\n\r\n```javascript\r\nfunction filterFunc(prefix, value) {\r\n  if (prefix == 'b') {\r\n    // Return an `undefined` value to omit a property.\r\n    return;\r\n  }\r\n  if (prefix == 'e[f]') {\r\n    return value.getTime();\r\n  }\r\n  if (prefix == 'e[g][0]') {\r\n    return value * 2;\r\n  }\r\n  return value;\r\n}\r\nQs.stringify({ a: 'b', c: 'd', e: { f: new Date(123), g: [2] } }, { filter: filterFunc })\r\n// 'a=b&c=d&e[f]=123&e[g][0]=4'\r\nQs.stringify({ a: 'b', c: 'd', e: 'f' }, { filter: ['a', 'e'] })\r\n// 'a=b&e=f'\r\nQs.stringify({ a: ['b', 'c', 'd'], e: 'f' }, { filter: ['a', 0, 2] })\r\n// 'a[0]=b&a[2]=d'\r\n```\r\n\r\n### Handling of `null` values\r\n\r\nBy default, `null` values are treated like empty strings:\r\n\r\n```javascript\r\nQs.stringify({ a: null, b: '' });\r\n// 'a=&b='\r\n```\r\n\r\nParsing does not distinguish between parameters with and without equal signs. Both are converted to empty strings.\r\n\r\n```javascript\r\nQs.parse('a&b=')\r\n// { a: '', b: '' }\r\n```\r\n\r\nTo distinguish between `null` values and empty strings use the `strictNullHandling` flag. In the result string the `null`\r\nvalues have no `=` sign:\r\n\r\n```javascript\r\nQs.stringify({ a: null, b: '' }, { strictNullHandling: true });\r\n// 'a&b='\r\n```\r\n\r\nTo parse values without `=` back to `null` use the `strictNullHandling` flag:\r\n\r\n```javascript\r\nQs.parse('a&b=', { strictNullHandling: true });\r\n// { a: null, b: '' }\r\n\r\n```\r\n\r\nTo completely skip rendering keys with `null` values, use the `skipNulls` flag:\r\n\r\n```javascript\r\nqs.stringify({ a: 'b', c: null}, { skipNulls: true })\r\n// 'a=b'\r\n```\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/hapijs/qs.git"
  },
  "scripts": {
    "dist": "browserify --standalone Qs lib/index.js > dist/qs.js",
    "test": "lab -a code -t 100 -L",
    "test-cov-html": "lab -a code -r html -o coverage.html",
    "test-tap": "lab -a code -r tap -o tests.tap"
  },
  "version": "6.0.1"
}
